import numpy as np

class ADRFGainTable:
    xx = np.arange(0.0, 60.1, 0.5)
    yy = np.array([
        
        0.000, 0.160, 0.188, 0.208, 0.225, 0.240, 0.253, 0.265,
        0.277, 0.287, 0.297, 0.307, 0.316, 0.325, 0.334, 0.343,
        0.351, 0.359, 0.367, 0.375, 0.383, 0.391, 0.398, 0.406,
        0.413, 0.420, 0.428, 0.435, 0.442, 0.449, 0.456, 0.463,
        0.470, 0.477, 0.484, 0.491, 0.498, 0.505, 0.512, 0.519,
        0.526, 0.533, 0.541, 0.548, 0.555, 0.562, 0.569, 0.576,
        0.583, 0.590, 0.597, 0.604, 0.612, 0.619, 0.626, 0.633,
        0.641, 0.648, 0.655, 0.662, 0.670, 0.677, 0.684, 0.692,
        0.699, 0.707, 0.714, 0.721, 0.729, 0.736, 0.744, 0.751,
        0.758, 0.766, 0.773, 0.781, 0.788, 0.796, 0.803, 0.811,
        0.818, 0.826, 0.833, 0.841, 0.848, 0.856, 0.863, 0.871,
        0.878, 0.886, 0.894, 0.901, 0.909, 0.917, 0.925, 0.933,
        0.941, 0.949, 0.957, 0.965, 0.974, 0.982, 0.991, 1.000,
        1.009, 1.018, 1.027, 1.037, 1.047, 1.057, 1.068, 1.079,
        1.091, 1.104, 1.117, 1.132, 1.148, 1.167, 1.190, 1.220,
        1.276, ])

    assert len(xx) == len(yy)

    @classmethod
    def gain_to_voltage(cls, gain):
        assert gain >=  0 and gain <= 60, f"Gain ({gain}) must be between 0 and 60 inclusive"
        
        for i, x in enumerate(cls.xx):
            if x > gain:
                break

        x0 = cls.xx[i-1]
        x1 = cls.xx[i]
        y0 = cls.yy[i-1]
        y1 = cls.yy[i]

        return (gain - x0) / (x1 - x0) * (y1 - y0) + y0

